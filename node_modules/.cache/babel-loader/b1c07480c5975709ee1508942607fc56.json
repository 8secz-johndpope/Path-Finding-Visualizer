{"ast":null,"code":"import PriorityQueue from \"js-priority-queue\";\n\nconst dijkstra = (grid, startNode, endNode, allowDiag) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let pq = new PriorityQueue({\n    comparator: function (a, b) {\n      return a.distance - b.distance;\n    }\n  });\n  grid.forEach(row => row.forEach(node => {\n    if (node.row === startNode.row && node.col === startNode.column) {\n      node.distance = 0;\n    } else node.distance = Infinity;\n\n    node.prevNode = null;\n  }));\n  pq.queue(grid[startNode.row][startNode.column]);\n\n  while (pq.length) {\n    const node = pq.dequeue();\n    const {\n      row,\n      col\n    } = node;\n    if (grid[row][col].isVisited) continue;\n    grid[row][col].isVisited = true;\n    visitedNodes.push(node); //if (node.distance === Infinity) break;\n\n    const n = [[1, 0], [0, 1], [-1, 0], [0, -1]]; //with diag\n\n    if (allowDiag) n.push([-1, 1], [1, 1], [-1, -1], [1, -1]);\n\n    for (let j = 0; j < n.length; j++) {\n      const i = n[j];\n      const r = row + i[0];\n      const c = col + i[1];\n\n      if (grid[r] && grid[r][c] && !grid[r][c].isVisited && (!grid[r][c].isWall || r === endNode.row && c === endNode.column)) {\n        if (r === endNode.row && c === endNode.column) {\n          grid[r][c].isVisited = true;\n          grid[r][c].prevNode = grid[row][col];\n          shortestPath = getShortestPath(grid[r][c]);\n          return {\n            visitedNodes,\n            shortestPath\n          };\n        }\n\n        const dist = Math.abs(i[0]) === 1 && Math.abs(i[1]) === 1 ? 1.4 : 1;\n\n        if (node.distance + dist < grid[r][c].distance) {\n          grid[r][c].prevNode = node;\n          grid[r][c].distance = node.distance + dist;\n        }\n\n        pq.queue(grid[r][c]);\n      }\n    }\n  }\n\n  return {\n    visitedNodes,\n    shortestPath\n  };\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n\n  return shortestPath;\n};\n\nexport default dijkstra;","map":{"version":3,"sources":["/media/aakash/2e3010a9-adce-4550-9e23-9a9e2129f7b4/aakash/PathfindingVis-master/src/algorithms/dijkstra.js"],"names":["PriorityQueue","dijkstra","grid","startNode","endNode","allowDiag","visitedNodes","shortestPath","pq","comparator","a","b","distance","forEach","row","node","col","column","Infinity","prevNode","queue","length","dequeue","isVisited","push","n","j","i","r","c","isWall","getShortestPath","dist","Math","abs","unshift","isShortestPath"],"mappings":"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","sourcesContent":["import PriorityQueue from \"js-priority-queue\";\n\nconst dijkstra = (grid, startNode, endNode, allowDiag) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let pq = new PriorityQueue({\n    comparator: function(a, b) {\n      return a.distance - b.distance;\n    }\n  });\n  grid.forEach(row =>\n    row.forEach(node => {\n      if (node.row === startNode.row && node.col === startNode.column) {\n        node.distance = 0;\n      } else node.distance = Infinity;\n      node.prevNode = null;\n    })\n  );\n  pq.queue(grid[startNode.row][startNode.column]);\n  while (pq.length) {\n    const node = pq.dequeue();\n    const { row, col } = node;\n    if (grid[row][col].isVisited) continue;\n    grid[row][col].isVisited = true;\n    visitedNodes.push(node);\n    //if (node.distance === Infinity) break;\n    const n = [\n      [1, 0],\n      [0, 1],\n      [-1, 0],\n      [0, -1]\n    ];\n    //with diag\n    if (allowDiag) n.push([-1, 1], [1, 1], [-1, -1], [1, -1]);\n    for (let j = 0; j < n.length; j++) {\n      const i = n[j];\n      const r = row + i[0];\n      const c = col + i[1];\n      if (\n        grid[r] &&\n        grid[r][c] &&\n        !grid[r][c].isVisited &&\n        (!grid[r][c].isWall || (r === endNode.row && c === endNode.column))\n      ) {\n        if (r === endNode.row && c === endNode.column) {\n          grid[r][c].isVisited = true;\n          grid[r][c].prevNode = grid[row][col];\n          shortestPath = getShortestPath(grid[r][c]);\n          return { visitedNodes, shortestPath };\n        }\n        const dist = Math.abs(i[0]) === 1 && Math.abs(i[1]) === 1 ? 1.4 : 1;\n        if (node.distance + dist < grid[r][c].distance) {\n          grid[r][c].prevNode = node;\n          grid[r][c].distance = node.distance + dist;\n        }\n        pq.queue(grid[r][c]);\n      }\n    }\n  }\n  return { visitedNodes, shortestPath };\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n  return shortestPath;\n};\n\nexport default dijkstra;\n"]},"metadata":{},"sourceType":"module"}