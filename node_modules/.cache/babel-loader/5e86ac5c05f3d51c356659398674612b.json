{"ast":null,"code":"var _jsxFileName = \"/media/aakash/2e3010a9-adce-4550-9e23-9a9e2129f7b4/aakash/PathfindingVis-master/src/components/Grid.js\";\nimport React from \"react\";\nimport Node from \"./Node\";\nimport dijkstra from \"../algorithms/dijkstra\";\nimport astar from \"../algorithms/astar\";\nimport jumpPointSearch from \"../algorithms/jumpPointSearch\";\nimport kruskal from \"../mazeGen/kruskall\";\nimport recursiveDivision from \"../mazeGen/recursiveDivison\";\nimport prim from \"../mazeGen/Prim\";\nimport Card from \"@material-ui/core/Card\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { connect } from \"react-redux\";\nimport { setAnimating, setVisited, setShortest } from \"../actions\";\nlet startNode = {\n  row: 20,\n  column: 4\n};\nlet endNode = {\n  row: 20,\n  column: 27\n};\nlet selectStart = false;\nlet selectEnd = false;\nlet selectWall = false;\nlet selectRemoveWall = false;\nlet isAnimated = false;\nconst startNodeClass = \"start-node\";\nconst endNodeClass = \"end-node\";\nconst wallClass = \"wall\";\nconst GridContainer = withStyles({\n  root: {\n    width: \"100%\",\n    padding: \"1vw\",\n    marginRight: \"1vw\"\n  }\n})(Card);\n\nclass TGrid extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.nodes = () => {\n      let nodes = [];\n\n      for (let i = 0; i < this.props.rows; i++) {\n        let nodeRow = [];\n\n        for (let j = 0; j < this.props.columns; j++) nodeRow.push( /*#__PURE__*/React.createElement(Node, {\n          key: i.toString() + \"-\" + j.toString(),\n          startNodeClass: startNodeClass,\n          endNodeClass: endNodeClass,\n          wallClass: wallClass,\n          row: this.state.grid[i][j].row,\n          column: this.state.grid[i][j].col,\n          isStart: this.state.grid[i][j].isStart,\n          isEnd: this.state.grid[i][j].isEnd,\n          isVisited: this.state.grid[i][j].isVisited,\n          isWall: this.state.grid[i][j].isWall,\n          isShortestPath: this.state.grid[i][j].isShortestPath,\n          onMouseClick: this.onMouseClick,\n          onMouseEnterAndLeave: this.onMouseEnterAndLeave,\n          ref: this.nodeRefs[i][j],\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 77,\n            columnNumber: 11\n          }\n        }));\n\n        nodes.push( /*#__PURE__*/React.createElement(\"tr\", {\n          key: i,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 94,\n            columnNumber: 18\n          }\n        }, nodeRow));\n      }\n\n      return nodes;\n    };\n\n    this.setGrid = async (grid = this.getInitGrid()) => {\n      if (selectEnd) {\n        selectEnd = false;\n        this.changeGridEndNode(endNode.row, endNode.column, grid);\n      }\n\n      if (selectStart) {\n        selectStart = false;\n        this.changeGridStartNode(startNode.row, startNode.column, grid);\n      }\n\n      if (selectWall) {\n        selectWall = false;\n        await this.setState({});\n      }\n\n      this.setState({\n        grid\n      });\n    };\n\n    this.getInitGrid = () => {\n      let grid = [];\n\n      for (let i = 0; i < this.props.rows; i++) {\n        let row = [];\n\n        for (let j = 0; j < this.props.columns; j++) row.push(this.getNode(i, j));\n\n        grid.push(row);\n      }\n\n      return grid;\n    };\n\n    this.getNode = (row, col) => {\n      return {\n        row,\n        col,\n        isStart: row === startNode.row && col === startNode.column,\n        isEnd: row === endNode.row && col === endNode.column,\n        isVisited: false,\n        isShortestPath: false,\n        isWall: false\n      };\n    };\n\n    this.onMouseClick = async (row, column) => {\n      if (this.props.anim) return;\n\n      if (selectStart) {\n        if (row !== endNode.row || column !== endNode.column) {\n          selectStart = false;\n          this.changeGridStartNode(row, column);\n        }\n      } else if (row === startNode.row && column === startNode.column && !selectEnd) {\n        selectStart = true;\n        if (this.state.grid[row][column].isWall) this.nodeRefs[row][column].current.classList.add(wallClass);\n      } else if (selectEnd) {\n        if (row !== startNode.row || column !== startNode.column) {\n          selectEnd = false;\n          this.changeGridEndNode(row, column);\n        }\n      } else if (row === endNode.row && column === endNode.column && !selectStart) {\n        selectEnd = true;\n        if (this.state.grid[row][column].isWall) this.nodeRefs[row][column].current.classList.add(wallClass);\n      } else if (selectWall) {\n        selectWall = false;\n        await this.setGrid(this.state.grid);\n      } else if (this.state.grid[row][column].isWall) {\n        selectRemoveWall = true;\n        this.nodeRefs[row][column].current.classList.remove(wallClass);\n        let grid = this.state.grid;\n        grid[row][column].isWall = false;\n        if (isAnimated) this.visualizeRealTime(startNode, endNode);\n      } else if (selectRemoveWall) {\n        selectRemoveWall = false;\n        await this.setGrid(this.state.grid);\n      } else {\n        selectWall = true;\n        this.nodeRefs[row][column].current.classList.add(wallClass);\n        let grid = this.state.grid;\n        grid[row][column].isWall = true;\n        if (isAnimated) this.visualizeRealTime(startNode, endNode);\n      }\n    };\n\n    this.onMouseEnterAndLeave = (row, column) => {\n      //Just changing the class using refs.\n      if (selectStart) {\n        if (row !== endNode.row || column !== endNode.column) {\n          this.nodeRefs[row][column].current.classList.toggle(startNodeClass);\n          if (isAnimated) this.visualizeRealTime({\n            row,\n            column\n          }, endNode);\n        }\n      } else if (selectEnd) {\n        if (row !== startNode.row || column !== startNode.column) {\n          this.nodeRefs[row][column].current.classList.toggle(endNodeClass);\n          if (isAnimated) this.visualizeRealTime(startNode, {\n            row,\n            column\n          });\n        }\n      } else if (selectWall) {\n        if ((row !== endNode.row || column !== endNode.column) && (row !== startNode.row || column !== startNode.column)) {\n          this.nodeRefs[row][column].current.classList.add(wallClass);\n          let grid = this.state.grid;\n          grid[row][column].isWall = true;\n          if (isAnimated) this.visualizeRealTime(startNode, endNode);\n        }\n      } else if (selectRemoveWall) {\n        if ((row !== endNode.row || column !== endNode.column) && (row !== startNode.row || column !== startNode.column)) {\n          this.nodeRefs[row][column].current.classList.remove(wallClass);\n          let grid = this.state.grid;\n          grid[row][column].isWall = false;\n          if (isAnimated) this.visualizeRealTime(startNode, endNode);\n        }\n      }\n    };\n\n    this.getRefs = () => {\n      let refs = [];\n\n      for (let i = 0; i < this.props.rows; i++) {\n        let rowRef = [];\n\n        for (let j = 0; j < this.props.columns; j++) rowRef.push(React.createRef());\n\n        refs.push(rowRef);\n      }\n\n      return refs;\n    };\n\n    this.changeGridStartNode = (row, column, grid = this.state.grid) => {\n      grid[startNode.row][startNode.column].isStart = false;\n      startNode = {\n        row,\n        column\n      };\n      grid[startNode.row][startNode.column].isStart = true;\n      this.nodeRefs[row][column].current.classList.add(startNodeClass);\n      this.setGrid(grid);\n    };\n\n    this.changeGridEndNode = (row, column, grid = this.state.grid) => {\n      grid[endNode.row][endNode.column].isEnd = false;\n      endNode = {\n        row,\n        column\n      };\n      grid[endNode.row][endNode.column].isEnd = true;\n      this.nodeRefs[row][column].current.classList.add(endNodeClass);\n      this.setGrid(grid);\n    };\n\n    this.clearVisited = grid => {\n      this.props.setVisited(0);\n      this.props.setShortest(0);\n      grid.forEach(row => row.forEach(node => {\n        node.isShortestPath = false;\n        node.isVisited = false;\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"visited\");\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"shortest-path\");\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"visited-anim\");\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"shortest-path-anim\");\n      }));\n    };\n\n    this.clearGrid = () => {\n      isAnimated = false;\n      this.props.setVisited(0);\n      this.props.setShortest(0);\n      this.setGrid();\n    };\n\n    this.visualize = async () => {\n      this.props.setAnimating(true);\n      let grid = this.state.grid;\n      await this.setGrid(grid);\n      this.clearVisited(grid);\n      const response = await this.getResponseFromAlgo(grid, startNode, endNode);\n      const {\n        visitedNodes,\n        shortestPath\n      } = response;\n      visitedNodes.shift();\n      shortestPath.shift();\n      shortestPath.pop();\n\n      if (visitedNodes.length === 0 && shortestPath.length === 0) {\n        this.props.setAnimating(false);\n        this.setGrid(grid);\n        return;\n      }\n\n      this.animate(visitedNodes, shortestPath, grid);\n    };\n\n    this.getResponseFromAlgo = (grid, sn, en) => {\n      let response;\n\n      switch (this.props.algo) {\n        case 0:\n          response = dijkstra(grid, sn, en, this.props.diag);\n          break;\n\n        case 1:\n          response = astar(grid, sn, en, this.props.heuristic[1], this.props.diag);\n          break;\n\n        case 2:\n          response = jumpPointSearch(grid, sn, en);\n          break;\n\n        default:\n          break;\n      }\n\n      return response;\n    };\n\n    this.animate = async (visitedNodes, shortestPath, grid) => {\n      let i = 0,\n          j = 0;\n\n      const animateVisitedNodes = async () => {\n        if (i === visitedNodes.length) {\n          if (shortestPath.length) requestAnimationFrame(animateShortestPath);else {\n            isAnimated = true;\n            this.props.setAnimating(false);\n            this.setGrid(grid);\n          }\n          return;\n        }\n\n        const {\n          row,\n          col\n        } = visitedNodes[i];\n        this.nodeRefs[row][col].current.classList.add(\"visited-anim\");\n        ++i;\n        this.props.setVisited(i);\n        requestAnimationFrame(animateVisitedNodes);\n      };\n\n      const animateShortestPath = () => {\n        if (j === shortestPath.length) {\n          isAnimated = true;\n          this.props.setAnimating(false);\n          this.setGrid(grid);\n          return;\n        }\n\n        const {\n          row,\n          col\n        } = shortestPath[j];\n        this.nodeRefs[row][col].current.classList.add(\"shortest-path-anim\");\n        ++j;\n        this.props.setShortest(j);\n        requestAnimationFrame(animateShortestPath);\n      };\n\n      await requestAnimationFrame(animateVisitedNodes);\n    };\n\n    this.visualizeRealTime = (sn, en) => {\n      let grid = this.state.grid;\n      this.clearVisited(grid);\n      const {\n        visitedNodes,\n        shortestPath\n      } = this.getResponseFromAlgo(grid, sn, en);\n      this.props.setVisited(visitedNodes.length);\n      this.props.setShortest(shortestPath.length);\n      visitedNodes.shift();\n      shortestPath.shift();\n      shortestPath.pop();\n      visitedNodes.forEach(node => {\n        this.nodeRefs[node.row][node.col].current.classList.add(\"visited\");\n      });\n      shortestPath.forEach(node => {\n        this.nodeRefs[node.row][node.col].current.classList.add(\"shortest-path\");\n      });\n      return {\n        visitedNodes,\n        shortestPath\n      };\n    };\n\n    this.visualizeMaze = async () => {\n      await this.clearGrid();\n      let grid = this.state.grid;\n\n      if (!this.props.animMaze) {\n        this.getResponseFromMaze(grid, this.props.maze);\n        await this.setGrid(grid);\n      } else {\n        this.props.setAnimating(true);\n        await this.setGrid(grid);\n        const {\n          addedWalls,\n          removedWalls,\n          animAddedWalls\n        } = this.getResponseFromMaze(grid);\n        this.animateMaze(addedWalls, removedWalls, grid, animAddedWalls);\n      }\n    };\n\n    this.getResponseFromMaze = grid => {\n      switch (this.props.maze) {\n        case 0:\n          return kruskal(grid, this.props.rows, this.props.columns);\n\n        case 1:\n          return prim(grid, this.props.rows, this.props.columns);\n\n        case 2:\n          return recursiveDivision(grid, this.props.rows, this.props.columns);\n\n        default:\n          break;\n      }\n    };\n\n    this.animateMaze = (addedWalls, removedWalls, grid, animAddedWalls) => {\n      let i = 0;\n\n      const animateAddedWalls = () => {\n        if (i === addedWalls.length) {\n          if (removedWalls.length) requestAnimationFrame(animateRemovedWalls);else {\n            this.props.setAnimating(false);\n            this.setGrid(grid);\n          }\n          return;\n        }\n\n        const {\n          row,\n          col\n        } = addedWalls[i];\n        this.nodeRefs[row][col].current.classList.add(wallClass);\n        ++i;\n        requestAnimationFrame(animateAddedWalls);\n      };\n\n      let j = 0;\n\n      const animateRemovedWalls = () => {\n        if (j === removedWalls.length) {\n          this.props.setAnimating(false);\n          this.setGrid(grid);\n          return;\n        }\n\n        const {\n          row,\n          col\n        } = removedWalls[j];\n        this.nodeRefs[row][col].current.classList.remove(wallClass);\n        ++j;\n        requestAnimationFrame(animateRemovedWalls);\n      };\n\n      const showAddedWalls = () => {\n        addedWalls.forEach(node => this.nodeRefs[node.row][node.col].current.classList.add(wallClass));\n      };\n\n      if (animAddedWalls) {\n        requestAnimationFrame(animateAddedWalls);\n      } else {\n        showAddedWalls();\n        requestAnimationFrame(animateRemovedWalls);\n      }\n    };\n\n    this.state = {\n      grid: []\n    };\n    this.nodeRefs = this.getRefs();\n    this.gridRef = React.createRef();\n  }\n\n  async componentDidMount() {\n    await this.setGrid();\n    this.gridRef.current.style.height = `${this.gridRef.current.offsetWidth / this.props.columns * this.props.rows}px`;\n    window.addEventListener(\"resize\", e => {\n      this.gridRef.current.style.height = `${this.gridRef.current.offsetWidth / this.props.columns * this.props.rows}px`;\n    });\n  }\n\n  render() {\n    if (isAnimated) {\n      const response = this.visualizeRealTime(startNode, endNode);\n      this.props.setVisited(response.visitedNodes.length);\n      this.props.setShortest(response.shortestPath.length);\n    }\n\n    if (this.state.grid.length === 0) return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 61,\n        columnNumber: 46\n      }\n    }, \"Loading...\");\n    return /*#__PURE__*/React.createElement(GridContainer, {\n      ref: this.gridRef,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 63,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"table\", {\n      className: \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 64,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"tbody\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 65,\n        columnNumber: 11\n      }\n    }, this.nodes())));\n  }\n\n}\n\nconst mapStateToProps = state => {\n  return {\n    algo: state.algo,\n    diag: state.diag,\n    heuristic: state.heuristic,\n    maze: state.maze,\n    animMaze: state.animMaze,\n    anim: state.anim\n  };\n};\n\nexport default connect(mapStateToProps, {\n  setAnimating,\n  setVisited,\n  setShortest\n}, null, {\n  forwardRef: true\n})(TGrid);","map":{"version":3,"sources":["/media/aakash/2e3010a9-adce-4550-9e23-9a9e2129f7b4/aakash/PathfindingVis-master/src/components/Grid.js"],"names":["React","Node","dijkstra","astar","jumpPointSearch","kruskal","recursiveDivision","prim","Card","withStyles","connect","setAnimating","setVisited","setShortest","startNode","row","column","endNode","selectStart","selectEnd","selectWall","selectRemoveWall","isAnimated","startNodeClass","endNodeClass","wallClass","GridContainer","root","width","padding","marginRight","TGrid","Component","constructor","props","nodes","i","rows","nodeRow","j","columns","push","toString","state","grid","col","isStart","isEnd","isVisited","isWall","isShortestPath","onMouseClick","onMouseEnterAndLeave","nodeRefs","setGrid","getInitGrid","changeGridEndNode","changeGridStartNode","setState","getNode","anim","current","classList","add","remove","visualizeRealTime","toggle","getRefs","refs","rowRef","createRef","clearVisited","forEach","node","clearGrid","visualize","response","getResponseFromAlgo","visitedNodes","shortestPath","shift","pop","length","animate","sn","en","algo","diag","heuristic","animateVisitedNodes","requestAnimationFrame","animateShortestPath","visualizeMaze","animMaze","getResponseFromMaze","maze","addedWalls","removedWalls","animAddedWalls","animateMaze","animateAddedWalls","animateRemovedWalls","showAddedWalls","gridRef","componentDidMount","style","height","offsetWidth","window","addEventListener","e","render","mapStateToProps","forwardRef"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport Node from \"./Node\";\nimport dijkstra from \"../algorithms/dijkstra\";\nimport astar from \"../algorithms/astar\";\nimport jumpPointSearch from \"../algorithms/jumpPointSearch\";\nimport kruskal from \"../mazeGen/kruskall\";\nimport recursiveDivision from \"../mazeGen/recursiveDivison\";\nimport prim from \"../mazeGen/Prim\";\nimport Card from \"@material-ui/core/Card\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { connect } from \"react-redux\";\nimport { setAnimating, setVisited, setShortest } from \"../actions\";\n\nlet startNode = { row: 20, column: 4 };\nlet endNode = { row: 20, column: 27 };\nlet selectStart = false;\nlet selectEnd = false;\nlet selectWall = false;\nlet selectRemoveWall = false;\nlet isAnimated = false;\n\nconst startNodeClass = \"start-node\";\nconst endNodeClass = \"end-node\";\nconst wallClass = \"wall\";\n\nconst GridContainer = withStyles({\n  root: {\n    width: \"100%\",\n    padding: \"1vw\",\n    marginRight: \"1vw\"\n  }\n})(Card);\n\nclass TGrid extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: []\n    };\n    this.nodeRefs = this.getRefs();\n    this.gridRef = React.createRef();\n  }\n  async componentDidMount() {\n    await this.setGrid();\n    this.gridRef.current.style.height = `${(this.gridRef.current.offsetWidth /\n      this.props.columns) *\n      this.props.rows}px`;\n    window.addEventListener(\"resize\", e => {\n      this.gridRef.current.style.height = `${(this.gridRef.current.offsetWidth /\n        this.props.columns) *\n        this.props.rows}px`;\n    });\n  }\n\n  render() {\n    if (isAnimated) {\n      const response = this.visualizeRealTime(startNode, endNode);\n      this.props.setVisited(response.visitedNodes.length);\n      this.props.setShortest(response.shortestPath.length);\n    }\n    if (this.state.grid.length === 0) return <div>Loading...</div>;\n    return (\n      <GridContainer ref={this.gridRef}>\n        <table className=\"grid\">\n          <tbody>{this.nodes()}</tbody>\n        </table>\n      </GridContainer>\n    );\n  }\n\n  nodes = () => {\n    let nodes = [];\n    for (let i = 0; i < this.props.rows; i++) {\n      let nodeRow = [];\n      for (let j = 0; j < this.props.columns; j++)\n        nodeRow.push(\n          <Node\n            key={i.toString() + \"-\" + j.toString()}\n            startNodeClass={startNodeClass}\n            endNodeClass={endNodeClass}\n            wallClass={wallClass}\n            row={this.state.grid[i][j].row}\n            column={this.state.grid[i][j].col}\n            isStart={this.state.grid[i][j].isStart}\n            isEnd={this.state.grid[i][j].isEnd}\n            isVisited={this.state.grid[i][j].isVisited}\n            isWall={this.state.grid[i][j].isWall}\n            isShortestPath={this.state.grid[i][j].isShortestPath}\n            onMouseClick={this.onMouseClick}\n            onMouseEnterAndLeave={this.onMouseEnterAndLeave}\n            ref={this.nodeRefs[i][j]}\n          />\n        );\n      nodes.push(<tr key={i}>{nodeRow}</tr>);\n    }\n    return nodes;\n  };\n  setGrid = async (grid = this.getInitGrid()) => {\n    if (selectEnd) {\n      selectEnd = false;\n      this.changeGridEndNode(endNode.row, endNode.column, grid);\n    }\n    if (selectStart) {\n      selectStart = false;\n      this.changeGridStartNode(startNode.row, startNode.column, grid);\n    }\n    if (selectWall) {\n      selectWall = false;\n      await this.setState({});\n    }\n    this.setState({ grid });\n  };\n\n  getInitGrid = () => {\n    let grid = [];\n    for (let i = 0; i < this.props.rows; i++) {\n      let row = [];\n      for (let j = 0; j < this.props.columns; j++) row.push(this.getNode(i, j));\n      grid.push(row);\n    }\n    return grid;\n  };\n  getNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === startNode.row && col === startNode.column,\n      isEnd: row === endNode.row && col === endNode.column,\n      isVisited: false,\n      isShortestPath: false,\n      isWall: false\n    };\n  };\n  onMouseClick = async (row, column) => {\n    if (this.props.anim) return;\n    if (selectStart) {\n      if (row !== endNode.row || column !== endNode.column) {\n        selectStart = false;\n        this.changeGridStartNode(row, column);\n      }\n    } else if (\n      row === startNode.row &&\n      column === startNode.column &&\n      !selectEnd\n    ) {\n      selectStart = true;\n      if (this.state.grid[row][column].isWall)\n        this.nodeRefs[row][column].current.classList.add(wallClass);\n    } else if (selectEnd) {\n      if (row !== startNode.row || column !== startNode.column) {\n        selectEnd = false;\n        this.changeGridEndNode(row, column);\n      }\n    } else if (\n      row === endNode.row &&\n      column === endNode.column &&\n      !selectStart\n    ) {\n      selectEnd = true;\n      if (this.state.grid[row][column].isWall)\n        this.nodeRefs[row][column].current.classList.add(wallClass);\n    } else if (selectWall) {\n      selectWall = false;\n      await this.setGrid(this.state.grid);\n    } else if (this.state.grid[row][column].isWall) {\n      selectRemoveWall = true;\n      this.nodeRefs[row][column].current.classList.remove(wallClass);\n      let grid = this.state.grid;\n      grid[row][column].isWall = false;\n      if (isAnimated) this.visualizeRealTime(startNode, endNode);\n    } else if (selectRemoveWall) {\n      selectRemoveWall = false;\n      await this.setGrid(this.state.grid);\n    } else {\n      selectWall = true;\n      this.nodeRefs[row][column].current.classList.add(wallClass);\n      let grid = this.state.grid;\n      grid[row][column].isWall = true;\n      if (isAnimated) this.visualizeRealTime(startNode, endNode);\n    }\n  };\n  onMouseEnterAndLeave = (row, column) => {\n    //Just changing the class using refs.\n    if (selectStart) {\n      if (row !== endNode.row || column !== endNode.column) {\n        this.nodeRefs[row][column].current.classList.toggle(startNodeClass);\n        if (isAnimated) this.visualizeRealTime({ row, column }, endNode);\n      }\n    } else if (selectEnd) {\n      if (row !== startNode.row || column !== startNode.column) {\n        this.nodeRefs[row][column].current.classList.toggle(endNodeClass);\n        if (isAnimated) this.visualizeRealTime(startNode, { row, column });\n      }\n    } else if (selectWall) {\n      if (\n        (row !== endNode.row || column !== endNode.column) &&\n        (row !== startNode.row || column !== startNode.column)\n      ) {\n        this.nodeRefs[row][column].current.classList.add(wallClass);\n        let grid = this.state.grid;\n        grid[row][column].isWall = true;\n        if (isAnimated) this.visualizeRealTime(startNode, endNode);\n      }\n    } else if (selectRemoveWall) {\n      if (\n        (row !== endNode.row || column !== endNode.column) &&\n        (row !== startNode.row || column !== startNode.column)\n      ) {\n        this.nodeRefs[row][column].current.classList.remove(wallClass);\n        let grid = this.state.grid;\n        grid[row][column].isWall = false;\n        if (isAnimated) this.visualizeRealTime(startNode, endNode);\n      }\n    }\n  };\n  getRefs = () => {\n    let refs = [];\n    for (let i = 0; i < this.props.rows; i++) {\n      let rowRef = [];\n      for (let j = 0; j < this.props.columns; j++)\n        rowRef.push(React.createRef());\n      refs.push(rowRef);\n    }\n    return refs;\n  };\n  changeGridStartNode = (row, column, grid = this.state.grid) => {\n    grid[startNode.row][startNode.column].isStart = false;\n    startNode = { row, column };\n    grid[startNode.row][startNode.column].isStart = true;\n    this.nodeRefs[row][column].current.classList.add(startNodeClass);\n    this.setGrid(grid);\n  };\n  changeGridEndNode = (row, column, grid = this.state.grid) => {\n    grid[endNode.row][endNode.column].isEnd = false;\n    endNode = { row, column };\n    grid[endNode.row][endNode.column].isEnd = true;\n    this.nodeRefs[row][column].current.classList.add(endNodeClass);\n    this.setGrid(grid);\n  };\n  clearVisited = grid => {\n    this.props.setVisited(0);\n    this.props.setShortest(0);\n    grid.forEach(row =>\n      row.forEach(node => {\n        node.isShortestPath = false;\n        node.isVisited = false;\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"visited\");\n        this.nodeRefs[node.row][node.col].current.classList.remove(\n          \"shortest-path\"\n        );\n        this.nodeRefs[node.row][node.col].current.classList.remove(\n          \"visited-anim\"\n        );\n        this.nodeRefs[node.row][node.col].current.classList.remove(\n          \"shortest-path-anim\"\n        );\n      })\n    );\n  };\n  clearGrid = () => {\n    isAnimated = false;\n    this.props.setVisited(0);\n    this.props.setShortest(0);\n    this.setGrid();\n  };\n  visualize = async () => {\n    this.props.setAnimating(true);\n    let grid = this.state.grid;\n    await this.setGrid(grid);\n    this.clearVisited(grid);\n    const response = await this.getResponseFromAlgo(grid, startNode, endNode);\n    const { visitedNodes, shortestPath } = response;\n    visitedNodes.shift();\n    shortestPath.shift();\n    shortestPath.pop();\n    if (visitedNodes.length === 0 && shortestPath.length === 0) {\n      this.props.setAnimating(false);\n      this.setGrid(grid);\n      return;\n    }\n    this.animate(visitedNodes, shortestPath, grid);\n  };\n  getResponseFromAlgo = (grid, sn, en) => {\n    let response;\n    switch (this.props.algo) {\n      case 0:\n        response = dijkstra(grid, sn, en, this.props.diag);\n        break;\n      case 1:\n        response = astar(\n          grid,\n          sn,\n          en,\n          this.props.heuristic[1],\n          this.props.diag\n        );\n        break;\n      case 2:\n        response = jumpPointSearch(grid, sn, en);\n        break;\n      default:\n        break;\n    }\n    return response;\n  };\n  animate = async (visitedNodes, shortestPath, grid) => {\n    let i = 0,\n      j = 0;\n    const animateVisitedNodes = async () => {\n      if (i === visitedNodes.length) {\n        if (shortestPath.length) requestAnimationFrame(animateShortestPath);\n        else {\n          isAnimated = true;\n          this.props.setAnimating(false);\n          this.setGrid(grid);\n        }\n        return;\n      }\n      const { row, col } = visitedNodes[i];\n      this.nodeRefs[row][col].current.classList.add(\"visited-anim\");\n      ++i;\n      this.props.setVisited(i);\n      requestAnimationFrame(animateVisitedNodes);\n    };\n    const animateShortestPath = () => {\n      if (j === shortestPath.length) {\n        isAnimated = true;\n        this.props.setAnimating(false);\n        this.setGrid(grid);\n        return;\n      }\n      const { row, col } = shortestPath[j];\n      this.nodeRefs[row][col].current.classList.add(\"shortest-path-anim\");\n      ++j;\n      this.props.setShortest(j);\n      requestAnimationFrame(animateShortestPath);\n    };\n    await requestAnimationFrame(animateVisitedNodes);\n  };\n\n  visualizeRealTime = (sn, en) => {\n    let grid = this.state.grid;\n    this.clearVisited(grid);\n    const { visitedNodes, shortestPath } = this.getResponseFromAlgo(\n      grid,\n      sn,\n      en\n    );\n    this.props.setVisited(visitedNodes.length);\n    this.props.setShortest(shortestPath.length);\n    visitedNodes.shift();\n    shortestPath.shift();\n    shortestPath.pop();\n    visitedNodes.forEach(node => {\n      this.nodeRefs[node.row][node.col].current.classList.add(\"visited\");\n    });\n    shortestPath.forEach(node => {\n      this.nodeRefs[node.row][node.col].current.classList.add(\"shortest-path\");\n    });\n    return { visitedNodes, shortestPath };\n  };\n\n  visualizeMaze = async () => {\n    await this.clearGrid();\n    let grid = this.state.grid;\n    if (!this.props.animMaze) {\n      this.getResponseFromMaze(grid, this.props.maze);\n      await this.setGrid(grid);\n    } else {\n      this.props.setAnimating(true);\n      await this.setGrid(grid);\n      const {\n        addedWalls,\n        removedWalls,\n        animAddedWalls\n      } = this.getResponseFromMaze(grid);\n      this.animateMaze(addedWalls, removedWalls, grid, animAddedWalls);\n    }\n  };\n\n  getResponseFromMaze = grid => {\n    switch (this.props.maze) {\n      case 0:\n        return kruskal(grid, this.props.rows, this.props.columns);\n      case 1:\n        return prim(grid, this.props.rows, this.props.columns);\n      case 2:\n        return recursiveDivision(grid, this.props.rows, this.props.columns);\n      default:\n        break;\n    }\n  };\n\n  animateMaze = (addedWalls, removedWalls, grid, animAddedWalls) => {\n    let i = 0;\n    const animateAddedWalls = () => {\n      if (i === addedWalls.length) {\n        if (removedWalls.length) requestAnimationFrame(animateRemovedWalls);\n        else {\n          this.props.setAnimating(false);\n          this.setGrid(grid);\n        }\n        return;\n      }\n      const { row, col } = addedWalls[i];\n      this.nodeRefs[row][col].current.classList.add(wallClass);\n      ++i;\n      requestAnimationFrame(animateAddedWalls);\n    };\n    let j = 0;\n    const animateRemovedWalls = () => {\n      if (j === removedWalls.length) {\n        this.props.setAnimating(false);\n        this.setGrid(grid);\n        return;\n      }\n      const { row, col } = removedWalls[j];\n      this.nodeRefs[row][col].current.classList.remove(wallClass);\n      ++j;\n      requestAnimationFrame(animateRemovedWalls);\n    };\n    const showAddedWalls = () => {\n      addedWalls.forEach(node =>\n        this.nodeRefs[node.row][node.col].current.classList.add(wallClass)\n      );\n    };\n    if (animAddedWalls) {\n      requestAnimationFrame(animateAddedWalls);\n    } else {\n      showAddedWalls();\n      requestAnimationFrame(animateRemovedWalls);\n    }\n  };\n}\n\nconst mapStateToProps = state => {\n  return {\n    algo: state.algo,\n    diag: state.diag,\n    heuristic: state.heuristic,\n    maze: state.maze,\n    animMaze: state.animMaze,\n    anim: state.anim\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n  { setAnimating, setVisited, setShortest },\n  null,\n  {\n    forwardRef: true\n  }\n)(TGrid);\n"]},"metadata":{},"sourceType":"module"}