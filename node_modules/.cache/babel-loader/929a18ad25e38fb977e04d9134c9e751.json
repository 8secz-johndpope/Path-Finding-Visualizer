{"ast":null,"code":"import PriorityQueue from \"js-priority-queue\";\n\nconst jumpPointSearch = (grid, startNode, endNode) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let pq = new PriorityQueue({\n    comparator: function (a, b) {\n      return a.node.f - b.node.f;\n    }\n  });\n  grid.forEach(row => {\n    row.forEach(node => {\n      //g : distance\n      node.g = Infinity; //f = g + h\n\n      node.f = Infinity;\n      node.prevNode = null;\n    });\n  });\n  grid[startNode.row][startNode.column].g = 0;\n  grid[startNode.row][startNode.column].f = H(startNode.row, startNode.column, endNode); //grid[startNode.row][startNode.column].isWall = false;\n  //grid[endNode.row][endNode.column].isWall = false;\n\n  const n = [[1, 0], [0, 1], [-1, 0], [0, -1], [-1, 1], [1, 1], [-1, -1], [1, -1]];\n  n.forEach(d => {\n    pq.queue({\n      node: grid[startNode.row][startNode.column],\n      dir: d\n    }); //grid[startNode.row][startNode.column].prevNode[d[0]][d[1]] = null;\n  });\n\n  while (pq.length) {\n    const obj = pq.dequeue();\n\n    if (!obj.node.isVisited) {\n      obj.node.isVisited = true;\n      visitedNodes.push(obj.node);\n    }\n    /*console.log(\n      obj.node.row + \",\" + obj.node.col + \"-dir:\" + obj.dir + \"-f:\" + obj.node.f\n    );*/\n\n\n    const response = scan(obj.node, obj.dir, grid, endNode, pq);\n\n    if (response === \"found\") {\n      break;\n    }\n  }\n\n  shortestPath = getShortestPath(grid[endNode.row][endNode.column]);\n  return {\n    visitedNodes,\n    shortestPath\n  };\n}; //x = c // y = r\n//hor = y // ver = x\n\n\nconst scan = (node, dir, grid, endNode, pq) => {\n  const x = dir[0];\n  const y = dir[1];\n\n  if (x !== 0 && y !== 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n\n    while (true) {\n      //console.log(\"diag\");\n      //console.log(r0, c0);\n      let c1 = c0 + y;\n      let r1 = r0 + x;\n      if (!inGrid(r1, c1, grid)) return false;\n      let g = grid[r1][c1];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r1, c1, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r1][c1].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n\n      if (g.isWall) return false;\n      grid[r1][c1].prevNode = grid[r0][c0];\n      let c2 = c1 + y;\n      let r2 = r1 + x;\n      let jump = false;\n\n      if (inGrid(r1, c0, grid) && grid[r1][c0].isWall && inGrid(r2, c0, grid) && (!grid[r2][c0].isWall || r2 === endNode.row && c0 === endNode.column)) {\n        pq.queue({\n          node: grid[r1][c1],\n          dir: [x, -y]\n        });\n        jump = true;\n      }\n\n      if (inGrid(r0, c1, grid) && grid[r0][c1].isWall && inGrid(r0, c2, grid) && (!grid[r0][c2].isWall || r0 === endNode.row && c2 === endNode.column)) {\n        pq.queue({\n          node: grid[r1][c1],\n          dir: [-x, y]\n        });\n        jump = true;\n      }\n\n      let hor = scan(grid[r1][c1], [0, y], grid, endNode, pq);\n      let ver = scan(grid[r1][c1], [x, 0], grid, endNode, pq);\n      if (hor === \"found\" || ver === \"found\") return \"found\";\n\n      if (hor || ver) {\n        jump = true;\n      }\n\n      if (jump) {\n        pq.queue({\n          node: grid[r1][c1],\n          dir: [x, y]\n        });\n        return true;\n      }\n\n      c0 = c1;\n      r0 = r1;\n    }\n  } else if (x === 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n\n    while (true) {\n      //console.log(\"row\");\n      //console.log(r0, c0);\n      let c1 = c0 + y;\n      if (!inGrid(r0, c1, grid)) return false;\n      let g = grid[r0][c1];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r0, c1, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r0][c1].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n\n      if (g.isWall) return false;\n      grid[r0][c1].prevNode = grid[r0][c0];\n      let c2 = c1 + y;\n      let jump = false;\n\n      if (inGrid(r0 - 1, c1, grid) && grid[r0 - 1][c1].isWall && inGrid(r0 - 1, c2, grid) && (!grid[r0 - 1][c2].isWall || r0 - 1 === endNode.row && c2 === endNode.column)) {\n        pq.queue({\n          node: grid[r0][c1],\n          dir: [-1, y]\n        });\n        jump = true;\n      }\n\n      if (inGrid(r0 + 1, c1, grid) && grid[r0 + 1][c1].isWall && inGrid(r0 + 1, c2, grid) && (!grid[r0 + 1][c2].isWall || r0 + 1 === endNode.row && c2 === endNode.column)) {\n        pq.queue({\n          node: grid[r0][c1],\n          dir: [1, y]\n        });\n        jump = true;\n      }\n\n      if (jump) {\n        pq.queue({\n          node: grid[r0][c1],\n          dir: [0, y]\n        });\n        return true;\n      }\n\n      c0 = c1;\n    }\n  } else if (y === 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n\n    while (true) {\n      //console.log(\"col\");\n      //console.log(r0, c0);\n      let r1 = r0 + x;\n      if (!inGrid(r1, c0, grid)) return false;\n      let g = grid[r1][c0];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r1, c0, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r1][c0].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n\n      if (g.isWall) return false;\n      grid[r1][c0].prevNode = grid[r0][c0];\n      let r2 = r1 + x;\n      let jump = false;\n\n      if (inGrid(r1, c0 - 1, grid) && grid[r1][c0 - 1].isWall && inGrid(r2, c0 - 1, grid) && (!grid[r2][c0 - 1].isWall || r2 === endNode.row && c0 - 1 === endNode.column)) {\n        pq.queue({\n          node: grid[r1][c0],\n          dir: [x, -1]\n        });\n        jump = true;\n      }\n\n      if (inGrid(r1, c0 + 1, grid) && grid[r1][c0 + 1].isWall && inGrid(r2, c0 + 1, grid) && (!grid[r2][c0 + 1].isWall || r2 === endNode.row && c0 + 1 === endNode.column)) {\n        pq.queue({\n          node: grid[r1][c0],\n          dir: [x, 1]\n        });\n        jump = true;\n      }\n\n      if (jump) {\n        pq.queue({\n          node: grid[r1][c0],\n          dir: [x, y]\n        });\n        return true;\n      }\n\n      r0 = r1;\n    }\n  }\n};\n\nconst inGrid = (row, col, grid) => {\n  return grid[row] && grid[row][col];\n};\n\nconst H = (row, col, endNode) => {\n  const dx = Math.abs(row - endNode.row);\n  const dy = Math.abs(col - endNode.column);\n  const d = 1;\n  let ans = d * Math.sqrt(dx * dx + dy * dy);\n  /*if (heuristic === \"manhatten\") {\n      ans = d * (dx + dy);\n    }\n    if (heuristic === \"euclidean\") {\n      ans = d * Math.sqrt(dx * dx + dy * dy);\n    }\n    if (heuristic === \"octile\" || heuristic === \"chebyshev\") {\n      let d2 = diagDist;\n      ans = d * Math.max(dx, dy) + (d2 - d) * Math.min(dx, dy);\n    }*/\n\n  return ans;\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n\n  return shortestPath;\n};\n\nexport default jumpPointSearch;","map":{"version":3,"sources":["/home/aakash/Desktop/PathfindingVis-master/src/algorithms/jumpPointSearch.js"],"names":["PriorityQueue","jumpPointSearch","grid","startNode","endNode","visitedNodes","shortestPath","pq","comparator","a","b","node","f","forEach","row","g","Infinity","prevNode","column","H","n","d","queue","dir","length","obj","dequeue","isVisited","push","response","scan","getShortestPath","x","y","r0","c0","col","c1","r1","inGrid","ng","nf","isWall","c2","r2","jump","hor","ver","dx","Math","abs","dy","ans","sqrt","unshift","isShortestPath"],"mappings":"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","sourcesContent":["import PriorityQueue from \"js-priority-queue\";\n\nconst jumpPointSearch = (grid, startNode, endNode) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let pq = new PriorityQueue({\n    comparator: function(a, b) {\n      return a.node.f - b.node.f;\n    }\n  });\n  grid.forEach(row => {\n    row.forEach(node => {\n      //g : distance\n      node.g = Infinity;\n      //f = g + h\n      node.f = Infinity;\n      node.prevNode = null;\n    });\n  });\n  grid[startNode.row][startNode.column].g = 0;\n  grid[startNode.row][startNode.column].f = H(\n    startNode.row,\n    startNode.column,\n    endNode\n  );\n  //grid[startNode.row][startNode.column].isWall = false;\n  //grid[endNode.row][endNode.column].isWall = false;\n  const n = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n    [-1, 1],\n    [1, 1],\n    [-1, -1],\n    [1, -1]\n  ];\n\n  n.forEach(d => {\n    pq.queue({ node: grid[startNode.row][startNode.column], dir: d });\n    //grid[startNode.row][startNode.column].prevNode[d[0]][d[1]] = null;\n  });\n  while (pq.length) {\n    const obj = pq.dequeue();\n    if (!obj.node.isVisited) {\n      obj.node.isVisited = true;\n      visitedNodes.push(obj.node);\n    }\n    /*console.log(\n      obj.node.row + \",\" + obj.node.col + \"-dir:\" + obj.dir + \"-f:\" + obj.node.f\n    );*/\n    const response = scan(obj.node, obj.dir, grid, endNode, pq);\n    if (response === \"found\") {\n      break;\n    }\n  }\n  shortestPath = getShortestPath(grid[endNode.row][endNode.column]);\n  return { visitedNodes, shortestPath };\n};\n//x = c // y = r\n//hor = y // ver = x\nconst scan = (node, dir, grid, endNode, pq) => {\n  const x = dir[0];\n  const y = dir[1];\n  if (x !== 0 && y !== 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n    while (true) {\n      //console.log(\"diag\");\n      //console.log(r0, c0);\n      let c1 = c0 + y;\n      let r1 = r0 + x;\n      if (!inGrid(r1, c1, grid)) return false;\n      let g = grid[r1][c1];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r1, c1, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r1][c1].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n      if (g.isWall) return false;\n      grid[r1][c1].prevNode = grid[r0][c0];\n      let c2 = c1 + y;\n      let r2 = r1 + x;\n      let jump = false;\n      if (\n        inGrid(r1, c0, grid) &&\n        grid[r1][c0].isWall &&\n        inGrid(r2, c0, grid) &&\n        (!grid[r2][c0].isWall || (r2 === endNode.row && c0 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r1][c1], dir: [x, -y] });\n        jump = true;\n      }\n      if (\n        inGrid(r0, c1, grid) &&\n        grid[r0][c1].isWall &&\n        inGrid(r0, c2, grid) &&\n        (!grid[r0][c2].isWall || (r0 === endNode.row && c2 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r1][c1], dir: [-x, y] });\n        jump = true;\n      }\n      let hor = scan(grid[r1][c1], [0, y], grid, endNode, pq);\n      let ver = scan(grid[r1][c1], [x, 0], grid, endNode, pq);\n      if (hor === \"found\" || ver === \"found\") return \"found\";\n      if (hor || ver) {\n        jump = true;\n      }\n      if (jump) {\n        pq.queue({ node: grid[r1][c1], dir: [x, y] });\n        return true;\n      }\n      c0 = c1;\n      r0 = r1;\n    }\n  } else if (x === 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n    while (true) {\n      //console.log(\"row\");\n      //console.log(r0, c0);\n      let c1 = c0 + y;\n      if (!inGrid(r0, c1, grid)) return false;\n      let g = grid[r0][c1];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r0, c1, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r0][c1].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n      if (g.isWall) return false;\n      grid[r0][c1].prevNode = grid[r0][c0];\n      let c2 = c1 + y;\n      let jump = false;\n      if (\n        inGrid(r0 - 1, c1, grid) &&\n        grid[r0 - 1][c1].isWall &&\n        inGrid(r0 - 1, c2, grid) &&\n        (!grid[r0 - 1][c2].isWall ||\n          (r0 - 1 === endNode.row && c2 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r0][c1], dir: [-1, y] });\n        jump = true;\n      }\n      if (\n        inGrid(r0 + 1, c1, grid) &&\n        grid[r0 + 1][c1].isWall &&\n        inGrid(r0 + 1, c2, grid) &&\n        (!grid[r0 + 1][c2].isWall ||\n          (r0 + 1 === endNode.row && c2 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r0][c1], dir: [1, y] });\n        jump = true;\n      }\n      if (jump) {\n        pq.queue({ node: grid[r0][c1], dir: [0, y] });\n        return true;\n      }\n      c0 = c1;\n    }\n  } else if (y === 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n    while (true) {\n      //console.log(\"col\");\n      //console.log(r0, c0);\n      let r1 = r0 + x;\n      if (!inGrid(r1, c0, grid)) return false;\n      let g = grid[r1][c0];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r1, c0, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r1][c0].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n      if (g.isWall) return false;\n      grid[r1][c0].prevNode = grid[r0][c0];\n      let r2 = r1 + x;\n      let jump = false;\n      if (\n        inGrid(r1, c0 - 1, grid) &&\n        grid[r1][c0 - 1].isWall &&\n        inGrid(r2, c0 - 1, grid) &&\n        (!grid[r2][c0 - 1].isWall ||\n          (r2 === endNode.row && c0 - 1 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r1][c0], dir: [x, -1] });\n        jump = true;\n      }\n      if (\n        inGrid(r1, c0 + 1, grid) &&\n        grid[r1][c0 + 1].isWall &&\n        inGrid(r2, c0 + 1, grid) &&\n        (!grid[r2][c0 + 1].isWall ||\n          (r2 === endNode.row && c0 + 1 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r1][c0], dir: [x, 1] });\n        jump = true;\n      }\n      if (jump) {\n        pq.queue({ node: grid[r1][c0], dir: [x, y] });\n        return true;\n      }\n      r0 = r1;\n    }\n  }\n};\n\nconst inGrid = (row, col, grid) => {\n  return grid[row] && grid[row][col];\n};\n\nconst H = (row, col, endNode) => {\n  const dx = Math.abs(row - endNode.row);\n  const dy = Math.abs(col - endNode.column);\n  const d = 1;\n  let ans = d * Math.sqrt(dx * dx + dy * dy);\n  /*if (heuristic === \"manhatten\") {\n      ans = d * (dx + dy);\n    }\n    if (heuristic === \"euclidean\") {\n      ans = d * Math.sqrt(dx * dx + dy * dy);\n    }\n    if (heuristic === \"octile\" || heuristic === \"chebyshev\") {\n      let d2 = diagDist;\n      ans = d * Math.max(dx, dy) + (d2 - d) * Math.min(dx, dy);\n    }*/\n  return ans;\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n  return shortestPath;\n};\n\nexport default jumpPointSearch;\n"]},"metadata":{},"sourceType":"module"}